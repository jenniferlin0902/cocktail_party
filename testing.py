from sklearn import svm
from sklearn.model_selection import cross_val_score

class cocktailSVMClassifier:
    '''
    SVM classifier for cocktail recipe with x = ingredient vector and y = correct recipe or not.
    train() train on cocktailData mixed with some fake data generated by cocktailData.
    test() take in either a list of x and y or a cocktailData type and output accurancy rate
    classify() take in a list of cocktail ingredients vector and return a list of prediction on whether
    each vector is a valid recipe
    @param train_data - cocktailData
    @param k - kernel options for svm
    '''
    def __init__(self, train_data, k='rbf'):
        self.data = train_data
        self.clf = svm.SVC()

    def train(self, verbose=0, validate=0):
        n_fake = self.data.n_recipe
        train= self.data.get_recipes_binary() + self.data.generate_fake(n_fake)
        print "--- training svm with {} real data and {} fake data ---".format(self.data.n_recipe, n_fake)
        train_x = [t[0] for t in train]
        train_y = [t[1] for t in train]
        if validate:
            score = cross_val_score(self.clf, train_x, y=train_y, cv=5, verbose=verbose)
            print score
        else:
            score = -1
        self.clf.fit(train_x, train_y)
        print "--- done training svm classifier ---"
        return score

    '''
    if y == None, assume its a cocktailData type
    else, x, and y should be an array
    '''
    def test(self, data, y=None):
        if y:
            test_x = data
            test_y = y
        else:
            test_x = data.get_recipes_binary_x()
            test_y = [1 for i in range(data.n_recipe)]
        print "---- testing {} recipe -----".format(len(test_x))
        predict_y = self.clf.predict(test_x)
        err = 0
        for i, y in enumerate(predict_y):
            if y != test_y[i]:
                err += 1
        return 1-err/float(len(test_x))

    def classify(self, x):
        return self.clf.predict(x)







